package tokenexchange

import (
	"context"
	"crypto/rand"
	"crypto/rsa"
	"crypto/x509"
	"encoding/base64"
	"encoding/json"
	"encoding/pem"
	"math/big"
	"net/http"
	"net/http/httptest"
	"testing"
	"time"

	"github.com/go-jose/go-jose/v4"
	"github.com/go-jose/go-jose/v4/jwt"
	"github.com/hashicorp/vault/sdk/logical"
	"github.com/stretchr/testify/require"
)

// generateTestKeyPair generates a test RSA key pair for signing JWTs
func generateTestKeyPair(t *testing.T) (*rsa.PrivateKey, string) {
	privateKey, err := rsa.GenerateKey(rand.Reader, 2048)
	require.NoError(t, err)

	privateKeyPEM := pem.EncodeToMemory(&pem.Block{
		Type:  "RSA PRIVATE KEY",
		Bytes: x509.MarshalPKCS1PrivateKey(privateKey),
	})

	return privateKey, string(privateKeyPEM)
}

// generateTestJWT generates a test JWT signed with the given private key
func generateTestJWT(t *testing.T, privateKey *rsa.PrivateKey, kid string, claims map[string]any) string {
	signer, err := jose.NewSigner(
		jose.SigningKey{Algorithm: jose.RS256, Key: privateKey},
		(&jose.SignerOptions{}).WithType("JWT").WithHeader("kid", kid),
	)
	require.NoError(t, err)

	builder := jwt.Signed(signer).Claims(claims)
	token, err := builder.Serialize()
	require.NoError(t, err)

	return token
}

// createMockJWKSServer creates a test HTTP server that serves a JWKS endpoint
func createMockJWKSServer(t *testing.T, publicKey *rsa.PublicKey, kid string) *httptest.Server {
	// Create JWK from public key
	jwk := jose.JSONWebKey{
		Key:       publicKey,
		KeyID:     kid,
		Algorithm: string(jose.RS256),
		Use:       "sig",
	}

	// Create JWKS
	jwks := jose.JSONWebKeySet{
		Keys: []jose.JSONWebKey{jwk},
	}

	// Create test server
	server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/json")
		err := json.NewEncoder(w).Encode(jwks)
		require.NoError(t, err)
	}))

	return server
}

// createTestKey creates a test key in storage and returns the key ID
// Keys are auto-generated by Vault (no import)
func createTestKey(t *testing.T, b *Backend, storage logical.Storage, keyName string) string {
	keyReq := &logical.Request{
		Operation: logical.CreateOperation,
		Path:      "key/" + keyName,
		Storage:   storage,
		Data: map[string]any{
			"algorithm": "RS256",
		},
	}
	keyResp, err := b.HandleRequest(context.Background(), keyReq)
	require.NoError(t, err)
	if keyResp != nil && keyResp.IsError() {
		t.Fatalf("key creation failed: %v", keyResp.Error())
	}
	require.NotNil(t, keyResp)
	require.NotNil(t, keyResp.Data)

	keyID, ok := keyResp.Data["key_id"].(string)
	require.True(t, ok, "key_id should be a string")
	return keyID
}

// getPublicKeyFromJWKS retrieves the public key for a given kid from Vault's JWKS endpoint
// This simulates how real consumers would verify tokens
func getPublicKeyFromJWKS(t *testing.T, b *Backend, storage logical.Storage, kid string) *rsa.PublicKey {
	jwksReq := &logical.Request{
		Operation: logical.ReadOperation,
		Path:      "jwks",
		Storage:   storage,
	}

	resp, err := b.HandleRequest(context.Background(), jwksReq)
	require.NoError(t, err)
	require.NotNil(t, resp)

	// Extract JWKS from HTTP raw body (JSON bytes)
	jwksJSON := resp.Data[logical.HTTPRawBody].([]byte)
	var jwksData map[string]any
	err = json.Unmarshal(jwksJSON, &jwksData)
	require.NoError(t, err, "Should be able to unmarshal JWKS JSON")

	// Convert []interface{} to []map[string]any
	keysInterface := jwksData["keys"].([]interface{})
	keys := make([]map[string]any, len(keysInterface))
	for i, k := range keysInterface {
		keys[i] = k.(map[string]interface{})
	}
	for _, jwk := range keys {
		if jwk["kid"].(string) == kid {
			// Decode JWK to RSA public key
			nStr := jwk["n"].(string)
			eStr := jwk["e"].(string)

			nBytes, err := base64.RawURLEncoding.DecodeString(nStr)
			require.NoError(t, err)

			eBytes, err := base64.RawURLEncoding.DecodeString(eStr)
			require.NoError(t, err)

			n := new(big.Int).SetBytes(nBytes)
			e := new(big.Int).SetBytes(eBytes)

			return &rsa.PublicKey{
				N: n,
				E: int(e.Int64()),
			}
		}
	}

	t.Fatalf("Key with kid %s not found in JWKS", kid)
	return nil
}

// TestTokenExchange_Success tests successful token exchange
func TestTokenExchange_Success(t *testing.T) {
	b, storage := getTestBackend(t)

	privateKey, _ := generateTestKeyPair(t)
	createTestKey(t, b, storage, "test-key")

	// Create mock JWKS server
	testKID := "test-key-1"
	jwksServer := createMockJWKSServer(t, &privateKey.PublicKey, testKID)
	defer jwksServer.Close()

	// Configure plugin
	configReq := &logical.Request{
		Operation: logical.UpdateOperation,
		Path:      "config",
		Storage:   storage,
		Data: map[string]any{
			"issuer":           "https://vault.example.com",
			"subject_jwks_uri": jwksServer.URL,			"default_ttl":      "1h",
		},
	}
	_, err := b.HandleRequest(context.Background(), configReq)
	require.NoError(t, err)

	// Create role
	roleReq := &logical.Request{
		Operation: logical.CreateOperation,
		Path:      "role/test-role",
		Storage:   storage,
		Data: map[string]any{
			"name":             "test-role",
			"ttl":              "1h",
   "key":              "test-key",
			"subject_template": `{"act": {"sub": "{{identity.subject.email}}"} }`,
			"actor_template":   `{"act": {"sub": "{{identity.entity.id}}"} }`,
			"context":          "urn:documents.service:read,urn:images.service:write",
		},
	}
	resp, err := b.HandleRequest(context.Background(), roleReq)
	require.NoError(t, err)

	respErr := resp.Error()
	require.NoError(t, respErr)

	// Generate subject token
	subjectClaims := map[string]any{
		"sub":   "user-123",
		"email": "user@example.com",
		"iss":   "https://idp.example.com",
		"aud":   []string{"service-a"},
		"exp":   time.Now().Add(1 * time.Hour).Unix(),
		"iat":   time.Now().Unix(),
	}
	subjectToken := generateTestJWT(t, privateKey, testKID, subjectClaims)

	// Exchange token
	tokenReq := &logical.Request{
		Operation: logical.UpdateOperation,
		Path:      "token/test-role",
		Storage:   storage,
		Data: map[string]any{
			"subject_token": subjectToken,
		},
		EntityID: "test_entity",
	}
	resp, err = b.HandleRequest(context.Background(), tokenReq)

	require.NoError(t, err, "Token exchange should succeed")
	require.NotNil(t, resp, "Should return response")
	require.NotNil(t, resp.Data, "Response should have data")
	require.Contains(t, resp.Data, "token", "Response should contain token")
	require.NotEmpty(t, resp.Data["token"], "Token should not be empty")
}

// TestTokenExchange_MissingSubjectToken tests validation of required subject_token
func TestTokenExchange_MissingSubjectToken(t *testing.T) {
	b, storage := getTestBackend(t)

	// Configure plugin
	configReq := &logical.Request{
		Operation: logical.UpdateOperation,
		Path:      "config",
		Storage:   storage,
		Data: map[string]any{
			"issuer":      "https://vault.example.com",			"default_ttl": "1h",
		},
	}
	// Create test key
	createTestKey(t, b, storage, "test-key")

	_, err := b.HandleRequest(context.Background(), configReq)
	require.NoError(t, err)

	// Create role
	roleReq := &logical.Request{
		Operation: logical.CreateOperation,
		Path:      "role/test-role",
		Storage:   storage,
		Data: map[string]any{
			"name":             "test-role",
			"ttl":              "1h",
   "key":              "test-key",
			"actor_template":   `{"act": {"sub": "agent-123"}}`,
			"subject_template": `{"department": "{{.identity.subject.department}}"}`,
			"context":          []string{"urn:documents:read"},
		},
	}
	_, err = b.HandleRequest(context.Background(), roleReq)
	require.NoError(t, err)

	// Exchange token without subject_token
	tokenReq := &logical.Request{
		Operation: logical.UpdateOperation,
		Path:      "token/test-role",
		Storage:   storage,
		Data:      map[string]any{
			// Missing subject_token
		},
	}
	resp, err := b.HandleRequest(context.Background(), tokenReq)

	require.NoError(t, err, "Handler should not error")
	require.NotNil(t, resp, "Should return error response")
	require.True(t, resp.IsError(), "Response should be an error")
	require.Contains(t, resp.Error().Error(), "subject_token", "Error should mention missing subject_token")
}

// TestTokenExchange_InvalidJWT tests handling of invalid JWT
func TestTokenExchange_InvalidJWT(t *testing.T) {
	b, storage := getTestBackend(t)

	// Configure plugin
	configReq := &logical.Request{
		Operation: logical.UpdateOperation,
		Path:      "config",
		Storage:   storage,
		Data: map[string]any{
			"issuer":      "https://vault.example.com",			"default_ttl": "1h",
		},
	}
	// Create test key
	createTestKey(t, b, storage, "test-key")

	_, err := b.HandleRequest(context.Background(), configReq)
	require.NoError(t, err)

	// Create role
	roleReq := &logical.Request{
		Operation: logical.CreateOperation,
		Path:      "role/test-role",
		Storage:   storage,
		Data: map[string]any{
			"name":             "test-role",
			"ttl":              "1h",
   "key":              "test-key",
			"actor_template":   `{"act": {"sub": "agent-123"}}`,
			"subject_template": `{"department": "{{.identity.subject.department}}"}`,
			"context":          []string{"urn:documents:read"},
		},
	}
	_, err = b.HandleRequest(context.Background(), roleReq)
	require.NoError(t, err)

	// Exchange with invalid JWT
	tokenReq := &logical.Request{
		Operation: logical.UpdateOperation,
		Path:      "token/test-role",
		Storage:   storage,
		Data: map[string]any{
			"subject_token": "invalid.jwt.token",
		},
	}
	resp, err := b.HandleRequest(context.Background(), tokenReq)

	require.NoError(t, err, "Handler should not error")
	require.NotNil(t, resp, "Should return error response")
	require.True(t, resp.IsError(), "Response should be an error")
}

// TestTokenExchange_ExpiredToken tests handling of expired JWT
func TestTokenExchange_ExpiredToken(t *testing.T) {
	b, storage := getTestBackend(t)

	privateKey, _ := generateTestKeyPair(t)
	createTestKey(t, b, storage, "test-key")

	// Create mock JWKS server
	testKID := "test-key-1"
	jwksServer := createMockJWKSServer(t, &privateKey.PublicKey, testKID)
	defer jwksServer.Close()

	// Configure plugin
	configReq := &logical.Request{
		Operation: logical.UpdateOperation,
		Path:      "config",
		Storage:   storage,
		Data: map[string]any{
			"issuer":           "https://vault.example.com",
			"subject_jwks_uri": jwksServer.URL,			"default_ttl":      "1h",
		},
	}
	_, err := b.HandleRequest(context.Background(), configReq)
	require.NoError(t, err)

	// Create role
	roleReq := &logical.Request{
		Operation: logical.CreateOperation,
		Path:      "role/test-role",
		Storage:   storage,
		Data: map[string]any{
			"name":             "test-role",
			"ttl":              "1h",
   "key":              "test-key",
			"actor_template":   `{"act": {"sub": "agent-123"}}`,
			"subject_template": `{"department": "{{.identity.subject.department}}"}`,
			"context":          []string{"urn:documents:read"},
		},
	}
	_, err = b.HandleRequest(context.Background(), roleReq)
	require.NoError(t, err)

	// Generate expired subject token
	expiredClaims := map[string]any{
		"sub": "user-123",
		"iss": "https://idp.example.com",
		"aud": []string{"service-a"},
		"exp": time.Now().Add(-1 * time.Hour).Unix(), // Expired 1 hour ago
		"iat": time.Now().Add(-2 * time.Hour).Unix(),
	}
	expiredToken := generateTestJWT(t, privateKey, testKID, expiredClaims)

	// Exchange expired token
	tokenReq := &logical.Request{
		Operation: logical.UpdateOperation,
		Path:      "token/test-role",
		Storage:   storage,
		Data: map[string]any{
			"subject_token": expiredToken,
		},
	}
	resp, err := b.HandleRequest(context.Background(), tokenReq)

	require.NoError(t, err, "Handler should not error")
	require.NotNil(t, resp, "Should return error response")
	require.True(t, resp.IsError(), "Response should be an error")
	require.Contains(t, resp.Error().Error(), "expired", "Error should mention expired token")
}

// TestTokenExchange_RoleNotFound tests handling when role doesn't exist
func TestTokenExchange_RoleNotFound(t *testing.T) {
	b, storage := getTestBackend(t)

	privateKey, _ := generateTestKeyPair(t)

	// Configure plugin
	// Create mock JWKS server
	testKID := "test-key-1"
	jwksServer := createMockJWKSServer(t, &privateKey.PublicKey, testKID)
	defer jwksServer.Close()

	configReq := &logical.Request{
		Operation: logical.UpdateOperation,
		Path:      "config",
		Storage:   storage,
		Data: map[string]any{
			"issuer":           "https://vault.example.com",
			"subject_jwks_uri": jwksServer.URL,			"default_ttl":      "1h",
		},
	}
	_, err := b.HandleRequest(context.Background(), configReq)
	require.NoError(t, err)

	// Generate subject token
	subjectClaims := map[string]any{
		"sub": "user-123",
		"iss": "https://idp.example.com",
		"aud": []string{"service-a"},
		"exp": time.Now().Add(1 * time.Hour).Unix(),
		"iat": time.Now().Unix(),
	}
	subjectToken := generateTestJWT(t, privateKey, testKID, subjectClaims)

	// Exchange token with non-existent role
	tokenReq := &logical.Request{
		Operation: logical.UpdateOperation,
		Path:      "token/nonexistent-role",
		Storage:   storage,
		Data: map[string]any{
			"subject_token": subjectToken,
		},
	}
	resp, err := b.HandleRequest(context.Background(), tokenReq)

	require.NoError(t, err, "Handler should not error")
	require.NotNil(t, resp, "Should return error response")
	require.True(t, resp.IsError(), "Response should be an error")
	require.Contains(t, resp.Error().Error(), "role", "Error should mention role not found")
}

// TestTokenExchange_VerifyGeneratedToken tests that the generated token is valid
func TestTokenExchange_VerifyGeneratedToken(t *testing.T) {
	b, storage := getTestBackend(t)

	privateKey, _ := generateTestKeyPair(t)
	createTestKey(t, b, storage, "test-key")

	// Create mock JWKS server
	testKID := "test-key-1"
	jwksServer := createMockJWKSServer(t, &privateKey.PublicKey, testKID)
	defer jwksServer.Close()

	// Configure plugin
	configReq := &logical.Request{
		Operation: logical.UpdateOperation,
		Path:      "config",
		Storage:   storage,
		Data: map[string]any{
			"issuer":           "https://vault.example.com",
			"subject_jwks_uri": jwksServer.URL,			"default_ttl":      "1h",
		},
	}
	_, err := b.HandleRequest(context.Background(), configReq)
	require.NoError(t, err)

	// Create role
	roleReq := &logical.Request{
		Operation: logical.CreateOperation,
		Path:      "role/test-role",
		Storage:   storage,
		Data: map[string]any{
			"name":             "test-role",
			"ttl":              "1h",
   "key":              "test-key",
			"actor_template":   `{"act": {"sub": "agent-123"}}`,
			"subject_template": `{"department": "{{.identity.subject.department}}"}`,
			"context":          []string{"urn:documents:read"},
		},
	}
	_, err = b.HandleRequest(context.Background(), roleReq)
	require.NoError(t, err)

	// Generate subject token
	subjectClaims := map[string]any{
		"sub":   "user-123",
		"email": "user@example.com",
		"iss":   "https://idp.example.com",
		"aud":   []string{"service-a"},
		"exp":   time.Now().Add(1 * time.Hour).Unix(),
		"iat":   time.Now().Unix(),
	}
	subjectToken := generateTestJWT(t, privateKey, testKID, subjectClaims)

	// Exchange token
	tokenReq := &logical.Request{
		Operation: logical.UpdateOperation,
		Path:      "token/test-role",
		Storage:   storage,
		EntityID:  "test_entity",
		Data: map[string]any{
			"subject_token": subjectToken,
		},
	}
	resp, err := b.HandleRequest(context.Background(), tokenReq)
	require.NoError(t, err)
	require.NotNil(t, resp, "Response should not be nil")
	if resp.IsError() {
		t.Fatalf("Token exchange failed: %v", resp.Error())
	}

	// Verify the generated token
	generatedToken, ok := resp.Data["token"].(string)
	require.True(t, ok, "Response should contain token as string")
	require.NotEmpty(t, generatedToken)

	// Parse and verify the token
	parsedToken, err := jwt.ParseSigned(generatedToken, []jose.SignatureAlgorithm{jose.RS256})
	require.NoError(t, err, "Generated token should be valid JWT")

	// Get the public key from JWKS endpoint
	vaultPublicKey := getPublicKeyFromJWKS(t, b, storage, "test-key-v1")

	claims := make(map[string]any)
	err = parsedToken.Claims(vaultPublicKey, &claims)
	require.NoError(t, err, "Should be able to verify signature with public key from JWKS")

	// Verify standard claims
	require.Equal(t, "https://vault.example.com", claims["iss"], "Issuer should match config")
	require.NotNil(t, claims["exp"], "Should have expiration")
	require.NotNil(t, claims["iat"], "Should have issued at")
	require.Equal(t, "user-123", claims["sub"], "Subject should be from original token")

	// Verify template claims were applied
	act, ok := claims["act"].(map[string]any)
	require.True(t, ok, "Should have act claim from template")
	require.Equal(t, "agent-123", act["sub"], "Agent sub should match template")
}

// TestTokenExchange_BoundIssuerMismatch tests that tokens with wrong issuer are rejected
func TestTokenExchange_BoundIssuerMismatch(t *testing.T) {
	b, storage := getTestBackend(t)

	// Create test key
	createTestKey(t, b, storage, "test-key")

	// Generate test key pair and JWKS server
	privateKey, _ := generateTestKeyPair(t)
	testKID := "test-key-1"
	jwksServer := createMockJWKSServer(t, &privateKey.PublicKey, testKID)
	defer jwksServer.Close()

	// Configure plugin
	configReq := &logical.Request{
		Operation: logical.UpdateOperation,
		Path:      "config",
		Storage:   storage,
		Data: map[string]any{
			"issuer":           "https://vault.example.com",
			"subject_jwks_uri": jwksServer.URL,			"default_ttl":      "1h",
		},
	}
	_, err := b.HandleRequest(context.Background(), configReq)
	require.NoError(t, err)

	// Create role with bound_issuer
	roleReq := &logical.Request{
		Operation: logical.CreateOperation,
		Path:      "role/test-role",
		Storage:   storage,
		Data: map[string]any{
			"name":             "test-role",
			"ttl":              "1h",
   "key":              "test-key",
			"bound_issuer":     "https://trusted-idp.example.com", // Required issuer
			"actor_template":   `{"act": {"sub": "agent-123"}}`,
			"subject_template": `{"department": "IT"}`,
			"context":          []string{"urn:documents:read"},
		},
	}
	_, err = b.HandleRequest(context.Background(), roleReq)
	require.NoError(t, err)

	// Generate subject token with DIFFERENT issuer
	subjectClaims := map[string]any{
		"sub": "user-123",
		"iss": "https://untrusted-idp.example.com", // WRONG ISSUER
		"aud": []string{"service-a"},
		"exp": time.Now().Add(1 * time.Hour).Unix(),
		"iat": time.Now().Unix(),
	}
	subjectToken := generateTestJWT(t, privateKey, testKID, subjectClaims)

	// Attempt token exchange
	tokenReq := &logical.Request{
		Operation: logical.UpdateOperation,
		Path:      "token/test-role",
		Storage:   storage,
		EntityID:  "test_entity",
		Data: map[string]any{
			"subject_token": subjectToken,
		},
	}
	resp, err := b.HandleRequest(context.Background(), tokenReq)

	require.NoError(t, err, "Handler should not panic")
	require.NotNil(t, resp, "Should return error response")
	require.True(t, resp.IsError(), "Response should be an error")
	require.Contains(t, resp.Error().Error(), "issuer", "Error should mention issuer mismatch")
}

// TestTokenExchange_BoundIssuerMatch tests that tokens with correct issuer are accepted
func TestTokenExchange_BoundIssuerMatch(t *testing.T) {
	b, storage := getTestBackend(t)

	// Create test key
	createTestKey(t, b, storage, "test-key")

	// Generate test key pair and JWKS server
	privateKey, _ := generateTestKeyPair(t)
	testKID := "test-key-1"
	jwksServer := createMockJWKSServer(t, &privateKey.PublicKey, testKID)
	defer jwksServer.Close()

	// Configure plugin
	configReq := &logical.Request{
		Operation: logical.UpdateOperation,
		Path:      "config",
		Storage:   storage,
		Data: map[string]any{
			"issuer":           "https://vault.example.com",
			"subject_jwks_uri": jwksServer.URL,			"default_ttl":      "1h",
		},
	}
	_, err := b.HandleRequest(context.Background(), configReq)
	require.NoError(t, err)

	// Create role with bound_issuer
	roleReq := &logical.Request{
		Operation: logical.CreateOperation,
		Path:      "role/test-role",
		Storage:   storage,
		Data: map[string]any{
			"name":             "test-role",
			"ttl":              "1h",
   "key":              "test-key",
			"bound_issuer":     "https://trusted-idp.example.com", // Required issuer
			"actor_template":   `{"act": {"sub": "agent-123"}}`,
			"subject_template": `{"department": "IT"}`,
			"context":          []string{"urn:documents:read"},
		},
	}
	_, err = b.HandleRequest(context.Background(), roleReq)
	require.NoError(t, err)

	// Generate subject token with MATCHING issuer
	subjectClaims := map[string]any{
		"sub": "user-123",
		"iss": "https://trusted-idp.example.com", // CORRECT ISSUER
		"aud": []string{"service-a"},
		"exp": time.Now().Add(1 * time.Hour).Unix(),
		"iat": time.Now().Unix(),
	}
	subjectToken := generateTestJWT(t, privateKey, testKID, subjectClaims)

	// Attempt token exchange
	tokenReq := &logical.Request{
		Operation: logical.UpdateOperation,
		Path:      "token/test-role",
		Storage:   storage,
		EntityID:  "test_entity",
		Data: map[string]any{
			"subject_token": subjectToken,
		},
	}
	resp, err := b.HandleRequest(context.Background(), tokenReq)

	require.NoError(t, err, "Handler should not error")
	require.NotNil(t, resp, "Should return response")
	require.False(t, resp.IsError(), "Response should not be an error")
	require.Contains(t, resp.Data, "token", "Should return token")
}

// TestTokenExchange_BoundAudienceMismatch tests that tokens with wrong audience are rejected
func TestTokenExchange_BoundAudienceMismatch(t *testing.T) {
	b, storage := getTestBackend(t)

	// Create test key
	createTestKey(t, b, storage, "test-key")

	// Generate test key pair and JWKS server
	privateKey, _ := generateTestKeyPair(t)
	testKID := "test-key-1"
	jwksServer := createMockJWKSServer(t, &privateKey.PublicKey, testKID)
	defer jwksServer.Close()

	// Configure plugin
	configReq := &logical.Request{
		Operation: logical.UpdateOperation,
		Path:      "config",
		Storage:   storage,
		Data: map[string]any{
			"issuer":           "https://vault.example.com",
			"subject_jwks_uri": jwksServer.URL,			"default_ttl":      "1h",
		},
	}
	_, err := b.HandleRequest(context.Background(), configReq)
	require.NoError(t, err)

	// Create role with bound_audiences
	roleReq := &logical.Request{
		Operation: logical.CreateOperation,
		Path:      "role/test-role",
		Storage:   storage,
		Data: map[string]any{
			"name":             "test-role",
			"ttl":              "1h",
   "key":              "test-key",
			"bound_audiences":  []string{"service-a", "service-b"}, // Allowed audiences
			"actor_template":   `{"act": {"sub": "agent-123"}}`,
			"subject_template": `{"department": "IT"}`,
			"context":          []string{"urn:documents:read"},
		},
	}
	_, err = b.HandleRequest(context.Background(), roleReq)
	require.NoError(t, err)

	// Generate subject token with DIFFERENT audience
	subjectClaims := map[string]any{
		"sub": "user-123",
		"iss": "https://idp.example.com",
		"aud": []string{"service-c"}, // WRONG AUDIENCE
		"exp": time.Now().Add(1 * time.Hour).Unix(),
		"iat": time.Now().Unix(),
	}
	subjectToken := generateTestJWT(t, privateKey, testKID, subjectClaims)

	// Attempt token exchange
	tokenReq := &logical.Request{
		Operation: logical.UpdateOperation,
		Path:      "token/test-role",
		Storage:   storage,
		EntityID:  "test_entity",
		Data: map[string]any{
			"subject_token": subjectToken,
		},
	}
	resp, err := b.HandleRequest(context.Background(), tokenReq)

	require.NoError(t, err, "Handler should not panic")
	require.NotNil(t, resp, "Should return error response")
	require.True(t, resp.IsError(), "Response should be an error")
	require.Contains(t, resp.Error().Error(), "audience", "Error should mention audience mismatch")
}

// TestTokenExchange_BoundAudienceMatch tests that tokens with correct audience are accepted
func TestTokenExchange_BoundAudienceMatch(t *testing.T) {
	b, storage := getTestBackend(t)

	// Create test key
	createTestKey(t, b, storage, "test-key")

	// Generate test key pair and JWKS server
	privateKey, _ := generateTestKeyPair(t)
	testKID := "test-key-1"
	jwksServer := createMockJWKSServer(t, &privateKey.PublicKey, testKID)
	defer jwksServer.Close()

	// Configure plugin
	configReq := &logical.Request{
		Operation: logical.UpdateOperation,
		Path:      "config",
		Storage:   storage,
		Data: map[string]any{
			"issuer":           "https://vault.example.com",
			"subject_jwks_uri": jwksServer.URL,			"default_ttl":      "1h",
		},
	}
	_, err := b.HandleRequest(context.Background(), configReq)
	require.NoError(t, err)

	// Create role with bound_audiences
	roleReq := &logical.Request{
		Operation: logical.CreateOperation,
		Path:      "role/test-role",
		Storage:   storage,
		Data: map[string]any{
			"name":             "test-role",
			"ttl":              "1h",
   "key":              "test-key",
			"bound_audiences":  []string{"service-a", "service-b"}, // Allowed audiences
			"actor_template":   `{"act": {"sub": "agent-123"}}`,
			"subject_template": `{"department": "IT"}`,
			"context":          []string{"urn:documents:read"},
		},
	}
	_, err = b.HandleRequest(context.Background(), roleReq)
	require.NoError(t, err)

	// Generate subject token with MATCHING audience (string format)
	subjectClaims := map[string]any{
		"sub": "user-123",
		"iss": "https://idp.example.com",
		"aud": "service-a", // CORRECT AUDIENCE (string)
		"exp": time.Now().Add(1 * time.Hour).Unix(),
		"iat": time.Now().Unix(),
	}
	subjectToken := generateTestJWT(t, privateKey, testKID, subjectClaims)

	// Attempt token exchange
	tokenReq := &logical.Request{
		Operation: logical.UpdateOperation,
		Path:      "token/test-role",
		Storage:   storage,
		EntityID:  "test_entity",
		Data: map[string]any{
			"subject_token": subjectToken,
		},
	}
	resp, err := b.HandleRequest(context.Background(), tokenReq)

	require.NoError(t, err, "Handler should not error")
	require.NotNil(t, resp, "Should return response")
	require.False(t, resp.IsError(), "Response should not be an error")
	require.Contains(t, resp.Data, "token", "Should return token")
}

// TestTokenExchange_BoundAudienceMatchArray tests array audience format
func TestTokenExchange_BoundAudienceMatchArray(t *testing.T) {
	b, storage := getTestBackend(t)

	// Create test key
	createTestKey(t, b, storage, "test-key")

	// Generate test key pair and JWKS server
	privateKey, _ := generateTestKeyPair(t)
	testKID := "test-key-1"
	jwksServer := createMockJWKSServer(t, &privateKey.PublicKey, testKID)
	defer jwksServer.Close()

	// Configure plugin
	configReq := &logical.Request{
		Operation: logical.UpdateOperation,
		Path:      "config",
		Storage:   storage,
		Data: map[string]any{
			"issuer":           "https://vault.example.com",
			"subject_jwks_uri": jwksServer.URL,			"default_ttl":      "1h",
		},
	}
	_, err := b.HandleRequest(context.Background(), configReq)
	require.NoError(t, err)

	// Create role with bound_audiences
	roleReq := &logical.Request{
		Operation: logical.CreateOperation,
		Path:      "role/test-role",
		Storage:   storage,
		Data: map[string]any{
			"name":             "test-role",
			"ttl":              "1h",
   "key":              "test-key",
			"bound_audiences":  []string{"service-a", "service-b"},
			"actor_template":   `{"act": {"sub": "agent-123"}}`,
			"subject_template": `{"department": "IT"}`,
			"context":          []string{"urn:documents:read"},
		},
	}
	_, err = b.HandleRequest(context.Background(), roleReq)
	require.NoError(t, err)

	// Generate subject token with MATCHING audience (array format)
	subjectClaims := map[string]any{
		"sub": "user-123",
		"iss": "https://idp.example.com",
		"aud": []string{"service-b", "other-service"}, // CORRECT AUDIENCE (array)
		"exp": time.Now().Add(1 * time.Hour).Unix(),
		"iat": time.Now().Unix(),
	}
	subjectToken := generateTestJWT(t, privateKey, testKID, subjectClaims)

	// Attempt token exchange
	tokenReq := &logical.Request{
		Operation: logical.UpdateOperation,
		Path:      "token/test-role",
		Storage:   storage,
		EntityID:  "test_entity",
		Data: map[string]any{
			"subject_token": subjectToken,
		},
	}
	resp, err := b.HandleRequest(context.Background(), tokenReq)

	require.NoError(t, err, "Handler should not error")
	require.NotNil(t, resp, "Should return response")
	require.False(t, resp.IsError(), "Response should not be an error")
	require.Contains(t, resp.Data, "token", "Should return token")
}

// TestTokenExchange_ActClaimStructure tests that generated tokens have RFC 8693 compliant act claim
func TestTokenExchange_ActClaimStructure(t *testing.T) {
	b, storage := getTestBackend(t)

	// Generate test key pair and JWKS server
	privateKey, _ := generateTestKeyPair(t)
	createTestKey(t, b, storage, "test-key")
	testKID := "test-key-1"
	jwksServer := createMockJWKSServer(t, &privateKey.PublicKey, testKID)
	defer jwksServer.Close()

	// Configure plugin
	configReq := &logical.Request{
		Operation: logical.UpdateOperation,
		Path:      "config",
		Storage:   storage,
		Data: map[string]any{
			"issuer":           "https://vault.example.com",
			"subject_jwks_uri": jwksServer.URL,			"default_ttl":      "1h",
		},
	}
	_, err := b.HandleRequest(context.Background(), configReq)
	require.NoError(t, err)

	// Create role
	roleReq := &logical.Request{
		Operation: logical.CreateOperation,
		Path:      "role/test-role",
		Storage:   storage,
		Data: map[string]any{
			"name":             "test-role",
			"ttl":              "1h",
   "key":              "test-key",
			"actor_template":   `{}`, // Empty template to use default
			"subject_template": `{"department": "IT"}`,
			"context":          []string{"urn:documents:read", "urn:images:write"},
		},
	}
	_, err = b.HandleRequest(context.Background(), roleReq)
	require.NoError(t, err)

	// Generate subject token
	subjectClaims := map[string]any{
		"sub":   "user-123",
		"email": "user@example.com",
		"iss":   "https://idp.example.com",
		"aud":   []string{"service-a"},
		"exp":   time.Now().Add(1 * time.Hour).Unix(),
		"iat":   time.Now().Unix(),
	}
	subjectToken := generateTestJWT(t, privateKey, testKID, subjectClaims)

	// Exchange token
	tokenReq := &logical.Request{
		Operation: logical.UpdateOperation,
		Path:      "token/test-role",
		Storage:   storage,
		EntityID:  "test-entity-456",
		Data: map[string]any{
			"subject_token": subjectToken,
		},
	}
	resp, err := b.HandleRequest(context.Background(), tokenReq)
	require.NoError(t, err)
	require.NotNil(t, resp)
	require.False(t, resp.IsError())

	// Parse generated token
	generatedToken := resp.Data["token"].(string)
	parsedToken, err := jwt.ParseSigned(generatedToken, []jose.SignatureAlgorithm{jose.RS256})
	require.NoError(t, err)

	// Get the public key from JWKS endpoint
	vaultPublicKey := getPublicKeyFromJWKS(t, b, storage, "test-key-v1")

	claims := make(map[string]any)
	err = parsedToken.Claims(vaultPublicKey, &claims)
	require.NoError(t, err)

	// Verify RFC 8693 compliant structure
	// 1. Subject is the user (not the actor)
	require.Equal(t, "user-123", claims["sub"], "Subject should be the user")

	// 2. act claim exists with actor identity
	act, ok := claims["act"].(map[string]any)
	require.True(t, ok, "Should have act claim")

	actSub, ok := act["sub"].(string)
	require.True(t, ok, "act.sub should be a string")
	require.NotEmpty(t, actSub, "act.sub should not be empty")
	require.Contains(t, actSub, "test-entity-456", "act.sub should contain entity ID")

	// 3. Optional: act.iss if present should be a string
	if actIss, ok := act["iss"]; ok {
		_, ok := actIss.(string)
		require.True(t, ok, "act.iss should be a string if present")
	}

	// 4. act claim should NOT contain non-identity claims
	_, hasExp := act["exp"]
	require.False(t, hasExp, "act should not contain exp claim")

	_, hasAud := act["aud"]
	require.False(t, hasAud, "act should not contain aud claim")

	_, hasIat := act["iat"]
	require.False(t, hasIat, "act should not contain iat claim")

	// 5. Scope claim should be space-delimited string
	scope, ok := claims["scope"].(string)
	require.True(t, ok, "scope should be a string")
	require.Contains(t, scope, " ", "scope should be space-delimited")
	require.Equal(t, "urn:documents:read urn:images:write", scope, "scope should be space-delimited")

	// 6. obo claim should NOT exist (deprecated)
	_, hasObo := claims["obo"]
	require.False(t, hasObo, "obo claim should not exist (replaced by act)")
}

// TestTokenExchange_ActorMetadataOptional tests that actor metadata is stored separately from act claim
func TestTokenExchange_ActorMetadataOptional(t *testing.T) {
	b, storage := getTestBackend(t)

	// Generate test key pair and JWKS server
	privateKey, _ := generateTestKeyPair(t)
	createTestKey(t, b, storage, "test-key")
	testKID := "test-key-1"
	jwksServer := createMockJWKSServer(t, &privateKey.PublicKey, testKID)
	defer jwksServer.Close()

	// Configure plugin
	configReq := &logical.Request{
		Operation: logical.UpdateOperation,
		Path:      "config",
		Storage:   storage,
		Data: map[string]any{
			"issuer":           "https://vault.example.com",
			"subject_jwks_uri": jwksServer.URL,			"default_ttl":      "1h",
		},
	}
	_, err := b.HandleRequest(context.Background(), configReq)
	require.NoError(t, err)

	// Create role with actor metadata in template
	roleReq := &logical.Request{
		Operation: logical.CreateOperation,
		Path:      "role/test-role",
		Storage:   storage,
		Data: map[string]any{
			"name": "test-role",
			"ttl":  "1h",
   "key":              "test-key",
			"actor_template": `{
				"actor_metadata": {
					"entity_id": "{{identity.entity.id}}",
					"entity_name": "{{identity.entity.name}}",
					"department": "AI Services"
				}
			}`,
			"subject_template": `{"department": "IT"}`,
			"context":          []string{"urn:documents:read"},
		},
	}
	_, err = b.HandleRequest(context.Background(), roleReq)
	require.NoError(t, err)

	// Generate subject token
	subjectClaims := map[string]any{
		"sub": "user-123",
		"iss": "https://idp.example.com",
		"aud": []string{"service-a"},
		"exp": time.Now().Add(1 * time.Hour).Unix(),
		"iat": time.Now().Unix(),
	}
	subjectToken := generateTestJWT(t, privateKey, testKID, subjectClaims)

	// Exchange token
	tokenReq := &logical.Request{
		Operation: logical.UpdateOperation,
		Path:      "token/test-role",
		Storage:   storage,
		EntityID:  "test-entity-456",
		Data: map[string]any{
			"subject_token": subjectToken,
		},
	}
	resp, err := b.HandleRequest(context.Background(), tokenReq)
	require.NoError(t, err)
	require.NotNil(t, resp)
	require.False(t, resp.IsError())

	// Parse generated token
	generatedToken := resp.Data["token"].(string)
	parsedToken, err := jwt.ParseSigned(generatedToken, []jose.SignatureAlgorithm{jose.RS256})
	require.NoError(t, err)

	// Get the public key from JWKS endpoint
	vaultPublicKey := getPublicKeyFromJWKS(t, b, storage, "test-key-v1")

	claims := make(map[string]any)
	err = parsedToken.Claims(vaultPublicKey, &claims)
	require.NoError(t, err)

	// Verify act claim contains ONLY identity
	act, ok := claims["act"].(map[string]any)
	require.True(t, ok, "Should have act claim")
	require.Contains(t, act, "sub", "act should have sub")
	require.NotContains(t, act, "entity_id", "act should not contain metadata")
	require.NotContains(t, act, "department", "act should not contain metadata")

	// Verify actor metadata is in separate namespace
	actorMetadata, ok := claims["actor_metadata"].(map[string]any)
	require.True(t, ok, "Should have actor_metadata namespace")
	require.Contains(t, actorMetadata, "entity_id", "actor_metadata should contain entity_id")
	require.Contains(t, actorMetadata, "department", "actor_metadata should contain department")
	require.Equal(t, "AI Services", actorMetadata["department"], "actor_metadata should have correct values")
}

// TestProcessTemplate_ArrayClaims tests that array claims (like permissions)
// are rendered as valid JSON arrays in mustache templates
func TestProcessTemplate_ArrayClaims(t *testing.T) {
	template := `{"email": "{{identity.subject.email}}", "permissions": {{identity.subject.permissions}}}`
	claims := map[string]any{
		"identity": map[string]map[string]any{
			"subject": {
				"email":       "john@example.com",
				"permissions": []any{"read:customers", "write:customers"},
			},
		},
	}

	result, err := processTemplate(template, claims)
	require.NoError(t, err)
	require.Equal(t, "john@example.com", result["email"])

	perms, ok := result["permissions"].([]any)
	require.True(t, ok, "permissions should be a JSON array")
	require.Len(t, perms, 2)
	require.Equal(t, "read:customers", perms[0])
	require.Equal(t, "write:customers", perms[1])
}

// TestProcessTemplate_StringClaims tests that string claims still work correctly
func TestProcessTemplate_StringClaims(t *testing.T) {
	template := `{"name": "{{identity.subject.name}}"}`
	claims := map[string]any{
		"identity": map[string]map[string]any{
			"subject": {
				"name": "John Doe",
			},
		},
	}

	result, err := processTemplate(template, claims)
	require.NoError(t, err)
	require.Equal(t, "John Doe", result["name"])
}
